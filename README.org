* Yo-yo

#+ATTR_HTML: title="Join the chat at https://gitter.im/james-henderson/yoyo"
[[https://gitter.im/james-henderson/yoyo?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge][file:https://badges.gitter.im/Join%20Chat.svg]]

Yo-yo is a lightweight library for composing 'Components' in a
functional style, in Clojure and ClojureScript, using Clojure's '[[https://github.com/funcool/cats][Cats]]'
monad library.

** Dependency:

#+BEGIN_SRC clojure
  [jarohen/yoyo "0.0.6-SNAPSHOT"]
#+END_SRC

There will likely be many breaking changes until 0.1.0!

** Rationale

Yo-yo came into existence after a few threads of conversation on the
Clojure mailing list, Twitter, and in real life (I know!). It seemed
that a number of people whose opinions I respect highly weren't quite
sold on Component and its derivatives (openly, including Phoenix) - a
few even said that Phoenix reminded them of Spring.

This obviously won't do!

So we did what Clojurians do: going to look at other languages to see
what they do, and pinching the best ideas; mostly Haskell, but a
couple of others as well - and Yo-yo is the result of those
discussions.

*** What Yo-yo is:

- A means of composing stoppable 'Components'
- Optionally, (via ~yoyo.system~) a means of composing Components that
  depend on other Components.
- That's it!

*** What Yo-yo isn't:

- A configuration library
- A Leiningen/Boot plugin
- A source of painful Java/OO/Spring memories ;)
- ...

*** What Yo-yo (core) isn't, but is also provided in this repo

- A module for starting/stopping Aleph/http-kit web servers.
- A module for compiling/building CLJS
- A module for starting/stopping JDBC connection pools
- Templates for creating webapps and REST APIs

** Getting Started - your first Yo-yo system

(There are a couple of Lein templates - 'yoyo-webapp' and 'yoyo-api',
but here follows a fuller explanation!)

I'm presuming you've added the Yo-yo dependency. It's at the top. Go
have a look and copy it into your project.clj/build.boot - I'll
wait :)

Yo-yo is based on two main data types: *Components* and *Dependents*.

*** Components

Components are just a pair - a value, and (optionally) a means of
'stopping' the value (whatever that may mean for the value in
question), created using ~yoyo.core/->component~. For example, for a
database pool, you could create a Yo-yo Component as follows:

#+BEGIN_SRC clojure
  (:require [yoyo.core :as yc])

  (defn open-db-pool! [db-config]
    (let [db-pool (start-db-pool! db-config)]
      (yc/->component db-pool
                      (fn []
                        (stop-db-pool! db-pool)))))
#+END_SRC

The interesting side to Components is that they compose very simply -
when we compose two Components together, we'd expect a combined
Component to have a combination of the two values, and a stop function
consisting of the two stop functions, in reverse order.

So, let's say we wanted to compose a database pool with a scheduler
that required a database pool, we'd want to compose them as follows:

#+BEGIN_SRC clojure
  (defn start-scheduler! [db-pool]
    (let [scheduled-task {:times ...
                          :schedule-fn (fn []
                                         (run-job! ... {:db-pool db-pool}))}
          stop-scheduler! (schedule! scheduled-task)]

      (yc/->component scheduled-task
                      (fn []
                        (stop-scheduler!)))))

  (defn combine-components [component f]
    ;; ...
    )

  (defn start-combined-component! [db-config]
    (let [db-pool-component (open-db-pool! db-config)]
      (combine-components db-pool-component
                          (fn [db-pool]
                            (start-scheduler! db-pool)))))
#+END_SRC

We'd expect ~start-combined-component!~ to return a Component with the
combined value, and a stop-function that first stops the scheduler,
then the database pool, as specified. This combined Component can then
be combined with other Components (combined or otherwise), using the
same ~combine-components~ function, to form a larger system.

What I've just described, is the monadic 'bind' function, over
Components - which, if it were written in Haskell, would have the
following type:

#+BEGIN_SRC haskell
  bind :: Component a -> (a -> Component b) -> Component b
#+END_SRC

We can then use all of the support in [[https://github.com/funcool/cats][Cats]] to build up our systems. I
won't duplicate its documentation here, but one macro in particular is
very useful: ~mlet~.

~mlet~ is structured similarly to Clojure's ~let~ bindings, except all
of the values on the right-hand-side are monadic values (in this case,
Components) which are then extracted and bound to the symbols on the
left, like Haskell's ~do~ notation:

#+BEGIN_SRC clojure
  (:require [cats.core :as c])

  (defn start-combined-component! [db-config]
    (c/mlet [db-pool (open-db-pool! db-config)
             scheduled-task (start-scheduler! db-pool)]
      (yc/->component {:db-pool db-pool
                       :scheduled-task scheduled-task})))
#+END_SRC

The value returned by the ~mlet~ is itself a monadic value, and hence
can itself be combined again into higher-level Components.

We don't have to worry about combining the stop-functions of the two
Components - the bind functionality, implemented by Yo-yo and called
by ~mlet~, handles all of that. Likewise, the Yo-yo bind
implementation includes error handling so that, if a subsequent
Component fails, the earlier Components are stopped - you aren't left
with a half-started system.

(Here, we're using the 1-arg version of ~yc/->component~, because the
combined Component doesn't require any 'stop' behaviour of its own,
above the stop-functions of the two individual Components.)

**** Testing a Component system

Components can be tested on their own, or as part of a combined
Component, using Yo-yo's ~yc/with-component~ function:

#+BEGIN_SRC clojure
  (deftest test-component
    (yc/with-component (open-db-pool! {...})
      (fn [db-pool]
        ;; test away!
        )))

  (deftest test-combination
    (yc/with-component (start-combined-component! {...})
      (fn [{:keys [db-pool scheduled-task]}]
        ;; test away!
        )))
#+END_SRC

~with-component~ passes the started Component to the given function,
and stops it when the function returns.

**** Starting/Stopping/Reloading a live Component system

Yo-yo has a few REPL utilities in the top-level ~yoyo~ namespace:
~yoyo/start!~, ~yoyo/stop!~ and ~yoyo/reload!~ - these allow you to
quickly start, stop and reload your system from the REPL. To set these
up, call ~yoyo/set-system-fn!~, passing it a 0-arg function returning
a Component, and then REPL away to your heart's content.

~yoyo/reload!~, by default, will stop the system, reload any
changed namespaces using clojure.tools.namespace, then restart the
system.

My ~-main~ functions, therefore, usually look something like this:

#+BEGIN_SRC clojure
  (ns myapp.main
    (:require [cats.core :as m]
              [yoyo :as y]))

  (defn make-system []
    (c/mlet [db-pool (open-db-pool! {...})
             ...]
      ...))

  (defn -main []
    (y/set-system-fn! #'make-system)

    (y/start!))
#+END_SRC

*** Dependents

=TODO=

** Templates

There are a couple of Leiningen templates that'll get you up and
running quickly - =yoyo-webapp= and =yoyo-api=. Run (e.g.) =lein new
yoyo-app your-app-name= to get started!

** Feedback/thoughts

Yes please! Yo-yo's still in its infancy, so I'd be particularly
interested to hear what you think - are we on the right lines here?

I can be contacted via Twitter, Github, e-mail (on my profile), Slack,
Gitter, you name it!

** Bug reports/PRs

Yes please to these too! Please submit through Github in the
traditional manner.

** Thanks!

A big thanks, in particular, to Kris Jenkins - who's provided a lot of
time, thoughts, advice and inspiration for the ideas behind
and around Yo-yo. Cheers Kris!

Thanks also to those involved in discussions about Component which
helped to shape Yo-yo, including (but not limited to)

- Michael Griffiths
- @mccraigmccraig
- Daniel Neal
- Yodit Stanton
- Neale Swinnerton
- Martin Trojer

Cheers!

James

** LICENCE

Copyright Â© 2015 James Henderson

Yo-yo, and all modules within this repo, are distributed under the
Eclipse Public License - either version 1.0 or (at your option) any
later version.
